## 규칙 15. 변경 가능성을 최소화하라

### 변경 불가능(immutable) 클래스
 - 객체를 수정할 수 없는 클래스 (String, 기본 자료형 클래스, BigInteger 등..)
 - 변경 가능 클래스보다 설계하기 쉽고, 구현하기 쉬우며, 사용하기 쉽다.
 - 오류 가능성도 적고, 더 안전하다.

### 변경 불가능 클래스의 다섯 규칙
### 1. 객체 상태를 변경하는 메서드(수정자 메서드 등)를 제공하지 않는다.
### 2. 계승할 수 없도록 한다.
 - 잘못 작성되거나 악의적인 하위 클래스가 변경 불가능성을 깨트리는 일을 막을 수 있다.
 - final로 선언하면 해결됨.

### 3. 모든 필드를 final로 선언한다.
 - 시스템이 강제하는 형태대로 프로그래머의 의도가 분명히 드러나며, 다른 스레드로 전달되어도 안전하다.

### 4. 모든 필드를 private로 선언한다.
 - 클라이언트가 필드가 참조하는 변경 가능 객체를 직접 수정하는 일을 막을 수 있다.
 - 참조 필드를 public으로 선언하는 방법도 있지만, 클래스의 내부 표현을 변경할 수 없게 되기 때문에 권장하지 않는다(규칙 13)

### 5. 변경 가능 컴포넌트에 대한 독점적 접근권을 보장한다.
 - 클래스 내의 변경 가능 객체에 대한 참조를 클라이언트는 획득할 수 없게 해야 한다.
 - 그러한 필드는 클라이언트가 초기화 해서는 안되고, 접근자 또한 그런 필드를 반환해서는 안된다.
 - 방어적 복사본을 만들어서 제공해야한다. (규칙 39, Date 예제)

### 6. 복소수 클래스 예제
```JAVA
public final class Complex {
  private final double re;
  private final double im;

  public Complex(double re, double im) {
    this.re = re;
    this.im = im;
  }

  // 대응되는 수정자가 없는 접근자들
  public double realPart() { return re; }

  public Complex add(Complex c) {
    return new Complex(re + c.re, im + c.im);
  }
  ...

}
```
 - 사칙연산 각각은 this 객체를 변경하는 대신 새로운 Complex 객체를 만들어 반환한다.(대부분의 변경 불가능 객체가 하는 방식)

### 7.  변경 불가능 객체는 단순하다.
 - 생성될 때 부여된 한 가지 상태만 갖는다.
 - 생성자가 불변식을 확실히 따르면 해당 객체는 불변식을 절대로 어기지 않게 된다.

### 8. 변경 불가능 객체는 thread-safe 하다.
 - 다른 스레드가 객체에 무슨 짓을 하는지 알 수 없지만, 변경 불가능한 객체이므로 안전하다.
 - 이를 이용하도록 장려하는 방법 : 자주 사용되는 값을 public static final 상수로 만들어 제공
   + public static final Complex ZERO = new Complex(0, 0);
   + public static final Complex ONE = new Complex(1, 0);

### 9.  변경 불가능 클래스는 자주 사용하는 객체를 캐시(cache)하여 정적 팩터리를 제공할 수 있다.
 - BigInteger, boxed primitive class는 그렇게 구현되어있다.
 - 메모리 요구량과 쓰레기 수집 비용이 줄어듦
 - 자유롭게 공유할 수 있으므로, 방어적 복사본을 만들 필요가 없다.

### 10. 변경 불가능한 객체는 그 내부도 공유할 수 있다.
 - BigInteger의 경우, 값의 부호와 크기를 각각 int / int[]으로 저장한다.
 - negate 메서드는 같은 크기의 값을 부호만 바꿔서 새로운 BigInteger 객체로 반환하지만, 배열은 같은 것을 참조한다.

### 11. 변경 불가능 객체는 다른 객체의 구성요소로도 훌륭하다.
 - map이나 set의 키, 원소로 사용하기 좋다.
   + 한번 집어넣고 나면 그 값이 변경되어 맵이나 집합의 불변식이 깨질 걱정은 하지 않아도 된다.

### 12. 유일한 단점은 값마다 별도의 객체를 만들어야 한다는 점이다.
 - BigInteger 객체의 경우, 값을 하나만 바꾸더라도(비트 개수가 100만개) 새로운 객체를 만들어야한다.
 - 단계별로 새로운 객체를 만들고, 결국에는 마지막 객체를 제외한 모든 객체를 버리는 연산의 경우 성능 문제는 더 커진다.
 - 해결 방안
    + 자주 요구되는 것을 기본 연산으로 제공함 : 클래스 내부에 package-private으로 선언된 변경 가능 "동료클래스"를 사용해 연산 속도를 높인다. (내부는 알 필요 업다고 한다.)


### 13. 대안적 설계법
 - final로 선언하는 것 보다, 모든 생성자를 private이나 package-private으로 선언하고, public 생성자 대신 정적 팩터리 메서드를 제공하는 것이 유연하다. (@Override?)
 - 외부 입장에서 보면 final과 마찬가지이다(상속 불가, public이나 protected로 선언된 생성자 없음)

### 14. 마무리
 - 어떤 메서드도 외부에서 **관측 가능한 상태 변화** 를 야기하지 않아야 한다.
 - 오래 걸리는 연산의 경우 캐싱하여 이용하면, 변경 불가능이므로, 같은 값이 항상 나오며 빠르다.
 - 변경 불가능 클래스가 Serializable 인터페이스를 구현하도록 했고, 변경 가능 객체를 참조하는 필드가 있다면, readObject 메서드나 readResolve 메서드를 반드시 제공해야한다.(방어적 복사본)
 - get 메서드마다 set 메서드를 둘 필요가 없다(변경 가능한 클래스로 만들 타당한 이유가 없다면, **반드시 변경 불가능 클래스로 만들어야 한다.**)
 - 변경 불가능하게 만들 수 없다면, **변경 가능성을 최대한 제한하라**.
 - 특별한 이유가 없다면 **모든 필드는 final로 선언하라.**
 - 생성자 이외의 public 초기화 메서드, 정적 팩터리 메서드, 재 초기화 메서드를 제공하지 마라.
